/*
 * @file   11.位运算_二进制中1的个数.cpp
 * @date   2019.3.16.
 * @author GBW
 * @Description: 实现一个函数，输入一个整数，输出该数二进制表示中1的个数。
 
 * @Note:
 
 */
0. 本质是把十进制数字用A-Z表示成二十六进制

1.异或：相同为0
	0. 右移：如果数字是一个无符号数值，则用0填充最左边的n位。
			 如果数字是一个有符号数值，则用符号位填补最左边的n位。如果一个数字原先是正数，则右移后补0，如果是负数，则右移后补1
	1. 左移：在最右边补上n个0

2.version_1
/*
	先判断整数二进制表示最右边一位是不是1.接着把输入的整数右移一位，此时原来处于从右边是数
	起的第二位被移到最右边。再判断是不是1，这样每次移动一位，直到整个整数变成0为止
*/
int NumberOf1(int n)
{
	int cnt = 0;
	while (n)
	{
		if (n & 1)
			cnt++;
		n = n >> 1;
	}
	return cnt;
}

3.version_2
/*
	version_1中，如果输入一个负数，如果一直做右移运算，最终这个数字就
	会变成0xFFFFFFFF而陷入死循环。(负数0x80000000右移一位的时候，并不是如正数一样变成0x40000000，而是0xC0000000.因为移位前就是负数，所以在移位之后也要保证是负数)
	故将代码更改为不右移输入的数字。
	而是首先把i和1做与运算，判断i的最低位是不是为1.接着把1左移一位得到2，再和i做与运算
*/
int NumberOf1(int n)
{
	int cnt = 0;
	unsigned int flag = 1;
	while (flag) // 循环次数等于整数二进制的位数，32位的整数需要循环32次
	{
		if (n & flag)
			cnt++;
		flag = flag << 1;
	}
	return cnt;
}


4.version_3
/*
	此方法整数中有几个1就只需要循环几次
	1100 & (1100 - 1) = 1100 & 1011 = 1000

	方法就是:把整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.
	那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

	*把一个整数减去1，都是把最右边的1变成0，如果它的右边还有0的话，所有的0都变成1，而它的左边都保持不变。
	如果是负数将高位的1也统计
*/
int NumberOf1(int n)
{
	int cnt = 0;
	while (n)
	{
		++cnt;
		n = (n - 1)&n;
	}
	return cnt;
}




























